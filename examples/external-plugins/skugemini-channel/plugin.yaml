# SKU Gemini Channel Plugin
# 基于 Gemini API，使用替换模式而非增量模式的流式传输

id: skugemini-channel
version: 1.0.0
name: SKU Gemini Channel
description: 基于 Gemini API，使用替换模式流式传输的渠道插件
author: IdoFront Team
homepage: https://github.com/nicekwell/IdoFront
icon: smart_toy

# ========== Channel 声明 ==========
channel:
  type: skugemini
  label: SKU Gemini
  defaults:
    baseUrl: https://generativelanguage.googleapis.com/v1beta
  capabilities:
    streaming: true
    vision: true

# ========== Channel 脚本（沙箱执行）==========
script: |
  (function() {
      'use strict';

      // Helper: Convert Gemini parts to displayable content and reasoning
      function partsToContent(parts) {
          if (!parts || !Array.isArray(parts)) return { content: '', reasoning: null };
          
          let content = '';
          let reasoning = '';
          
          for (const part of parts) {
              if (part.text) {
                  // Check if this is a thought part
                  if (part.thought === true) {
                      reasoning += part.text;
                  } else {
                      content += part.text;
                  }
              }
              if (part.inlineData) {
                  const { mimeType, data } = part.inlineData;
                  content += `\n![Generated Image](data:${mimeType};base64,${data})\n`;
              }
          }
          
          return {
              content,
              reasoning: reasoning || null
          };
      }

      // Helper: Convert message to Gemini format
      function convertMessages(messages) {
          const contents = [];
          let systemInstruction = undefined;

          for (const msg of messages) {
              if (msg.role === 'system') {
                  const geminiData = msg.metadata?.gemini;
                  systemInstruction = {
                      parts: geminiData?.parts || [{ text: msg.content || '' }]
                  };
              } else {
                  const role = msg.role === 'assistant' ? 'model' : 'user';
                  const geminiData = msg.metadata?.gemini;
                  
                  let parts = [];
                  
                  if (geminiData?.parts) {
                      parts = geminiData.parts;
                  } else {
                      if (msg.content) {
                          parts.push({ text: msg.content });
                      }
                      
                      if (role === 'user' && msg.metadata?.attachments) {
                          for (const attachment of msg.metadata.attachments) {
                              if (attachment.type && attachment.type.startsWith('image/')) {
                                  const base64Data = attachment.dataUrl.split(',')[1];
                                  parts.push({
                                      inlineData: {
                                          mimeType: attachment.type,
                                          data: base64Data
                                      }
                                  });
                              }
                          }
                      }
                  }
                  
                  const geminiMsg = {
                      role: role,
                      parts: parts
                  };
                  
                  if (geminiData?.thoughtSignature && role === 'model') {
                      geminiMsg.thoughtSignature = geminiData.thoughtSignature;
                  }
                  
                  contents.push(geminiMsg);
              }
          }
          return { contents, systemInstruction };
      }

      const adapter = {
          async call(messages, config, onUpdate, signal) {
              let baseUrl = config.baseUrl;
              if (!baseUrl || !baseUrl.trim()) {
                  baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
              }
              baseUrl = baseUrl.replace(/\/+$/, '');
              
              let model = config.model;
              if (model.startsWith('models/')) {
                  model = model.substring(7);
              }

              const isStream = !!onUpdate;
              const action = isStream ? 'streamGenerateContent' : 'generateContent';
              
              let url = `${baseUrl}/models/${model}:${action}`;
              if (isStream) {
                  url += '?alt=sse';
              }

              const { contents, systemInstruction } = convertMessages(messages);

              const body = {
                  contents: contents
              };
              
              if (systemInstruction) {
                  body.systemInstruction = systemInstruction;
              }

              const generationConfig = {};
              if (config.temperature !== undefined) generationConfig.temperature = parseFloat(config.temperature);
              if (config.topP !== undefined) generationConfig.topP = parseFloat(config.topP);
              if (config.maxTokens !== undefined) generationConfig.maxOutputTokens = parseInt(config.maxTokens);
              
              if (Object.keys(generationConfig).length > 0) {
                  body.generationConfig = generationConfig;
              }

              if (config.paramsOverride && typeof config.paramsOverride === 'object') {
                  Object.assign(body, config.paramsOverride);
              }

              const headers = {
                  'Content-Type': 'application/json',
                  'x-goog-api-key': config.apiKey
              };

              if (config.customHeaders && Array.isArray(config.customHeaders)) {
                  config.customHeaders.forEach(header => {
                      if (header.key && header.value) {
                          headers[header.key] = header.value;
                      }
                  });
              }

              try {
                  const response = await fetch(url, {
                      method: 'POST',
                      headers: headers,
                      body: JSON.stringify(body),
                      signal: signal
                  });

                  if (!response.ok) {
                      const errorText = await response.text();
                      let errorMsg = `SKUgemini API Error ${response.status}`;
                      try {
                          const errorJson = JSON.parse(errorText);
                          if (errorJson.error && errorJson.error.message) {
                              errorMsg += `: ${errorJson.error.message}`;
                          } else {
                              errorMsg += `: ${errorText}`;
                          }
                      } catch (e) {
                          errorMsg += `: ${errorText}`;
                      }
                      throw new Error(errorMsg);
                  }

                  if (isStream) {
                      const reader = response.body.getReader();
                      const decoder = new TextDecoder("utf-8");
                      let buffer = '';
                      let lastParts = [];
                      let lastThoughtSignature = null;

                      try {
                          while (true) {
                              const { done, value } = await reader.read();
                              if (done) break;
                              
                              buffer += decoder.decode(value, { stream: true });
                              const lines = buffer.split('\n');
                              buffer = lines.pop();

                              for (const line of lines) {
                                  const trimmed = line.trim();
                                  if (!trimmed) continue;
                                  
                                  if (trimmed.startsWith('data: ')) {
                                      const jsonStr = trimmed.substring(6);
                                      if (jsonStr === '[DONE]') continue;

                                      try {
                                          const json = JSON.parse(jsonStr);
                                          const candidate = json.candidates?.[0];
                                          if (candidate && candidate.content && candidate.content.parts) {
                                              const newParts = candidate.content.parts;
                                              const thoughtSignature = candidate.thoughtSignature;
                                              
                                              // SKUgemini 特性：直接替换而非累积
                                              lastParts = newParts;
                                              lastThoughtSignature = thoughtSignature;
                                              
                                              const { content, reasoning } = partsToContent(newParts);
                                              
                                              onUpdate({
                                                  content: content,
                                                  reasoning: reasoning,
                                                  metadata: {
                                                      gemini: {
                                                          parts: newParts,
                                                          thoughtSignature: thoughtSignature
                                                      }
                                                  }
                                              });
                                          }
                                      } catch (e) {
                                          console.warn('Error parsing SKUgemini stream data:', e);
                                      }
                                  }
                              }
                          }
                      } catch (streamError) {
                          if (streamError.name === 'AbortError') {
                              console.log('[SKUgemini] Stream aborted by user');
                          } else {
                              console.error('Stream reading error:', streamError);
                              throw streamError;
                          }
                      }

                      const { content, reasoning } = partsToContent(lastParts);
                      
                      return {
                          choices: [{
                              message: {
                                  role: 'assistant',
                                  content: content,
                                  reasoning_content: reasoning,
                                  metadata: {
                                      gemini: {
                                          parts: lastParts,
                                          thoughtSignature: lastThoughtSignature
                                      }
                                  }
                              }
                          }]
                      };

                  } else {
                      const data = await response.json();
                      const candidate = data.candidates?.[0];
                      const parts = candidate?.content?.parts || [];
                      const thoughtSignature = candidate?.thoughtSignature;
                      const { content, reasoning } = partsToContent(parts);
                      
                      return {
                          choices: [{
                              message: {
                                  role: 'assistant',
                                  content: content,
                                  reasoning_content: reasoning,
                                  metadata: {
                                      gemini: {
                                          parts: parts,
                                          thoughtSignature: thoughtSignature
                                      }
                                  }
                              }
                          }]
                      };
                  }

              } catch (error) {
                  if (error.name === 'AbortError') {
                      console.log('[SKUgemini] Request aborted');
                      return {
                          choices: [{
                              message: {
                                  role: 'assistant',
                                  content: '',
                                  reasoning_content: null
                              }
                          }]
                      };
                  }
                  console.error('SKUgemini Channel Error:', error);
                  throw error;
              }
          },

          async fetchModels(config) {
              let baseUrl = config.baseUrl;
              if (!baseUrl || !baseUrl.trim()) {
                  baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
              }
              baseUrl = baseUrl.replace(/\/+$/, '');
              
              let allModels = [];
              let pageToken = null;
              
              try {
                  do {
                      let url = `${baseUrl}/models?pageSize=1000`;
                      if (pageToken) {
                          url += `&pageToken=${encodeURIComponent(pageToken)}`;
                      }
                      
                      const response = await fetch(url, {
                          method: 'GET',
                          headers: {
                              'Content-Type': 'application/json',
                              'x-goog-api-key': config.apiKey
                          }
                      });

                      if (!response.ok) {
                          const errorText = await response.text();
                          throw new Error(`获取模型失败 ${response.status}: ${errorText}`);
                      }

                      const data = await response.json();
                      
                      if (data.models && Array.isArray(data.models)) {
                          const models = data.models.map(m => m.name.replace(/^models\//, ''));
                          allModels = allModels.concat(models);
                      }
                      
                      pageToken = data.nextPageToken;
                      
                  } while (pageToken);

                  return allModels.sort();
                  
              } catch (error) {
                  console.error('Fetch SKUgemini Models Error:', error);
                  throw error;
              }
          }
      };

      Plugin.registerChannel(adapter);
  })();