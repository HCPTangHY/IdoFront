# Gemini Deep Research Channel Plugin
# æ··åˆæ ¼å¼æ’ä»¶ç¤ºä¾‹ï¼šYAML å£°æ˜Ž UI/Settingsï¼ŒJS å®žçŽ° Channel é€»è¾‘

id: gemini-deep-research
version: 1.0.0
name: Gemini Deep Research
description: å¤šæ­¥éª¤ç ”ç©¶ä»»åŠ¡ï¼Œé€‚ç”¨äºŽå¸‚åœºåˆ†æžã€æ–‡çŒ®ç»¼è¿°ã€ç«žå“åˆ†æžç­‰åœºæ™¯
author: IdoFront Team
icon: science

# ========== Channel å£°æ˜Ž ==========
channel:
  type: gemini-deep-research
  label: Gemini Deep Research
  defaults:
    baseUrl: https://generativelanguage.googleapis.com/v1beta
    model: deep-research-pro-preview-12-2025
  capabilities:
    streaming: true
    vision: false

# ========== UI å£°æ˜Žï¼ˆä¸»çº¿ç¨‹ç›´æŽ¥æ¸²æŸ“ï¼Œé›¶å»¶è¿Ÿï¼‰==========
ui:
  INPUT_TOP:
    - id: deep-research-status
      component: md-container
      visible: $channel.type == 'gemini-deep-research'
      props:
        class: flex items-center gap-2
        children:
          - component: md-divider
            props:
              class: h-5 w-px bg-gray-200
          - component: md-text
            props:
              class: text-[10px] text-gray-400
              text: ç ”ç©¶
          - component: md-chip
            props:
              class: text-[10px] cursor-help
              variants:
                - when: $meta.previousInteractionId
                  text: ç»­å†™æ¨¡å¼
                  color: green
                  title: äº¤äº’ ID å·²ä¿å­˜ï¼Œå¯ç»§ç»­æé—®
                - default: true
                  text: æ–°ç ”ç©¶
                  color: blue
                  title: å°†å¼€å§‹ä¸€ä¸ªå…¨æ–°çš„æ·±åº¦ç ”ç©¶ä»»åŠ¡
      actions:
        clear:
          icon: close
          class: text-[10px] text-gray-400 hover:text-red-500 transition-colors
          title: æ¸…é™¤ç»­å†™çŠ¶æ€ï¼Œå¼€å§‹æ–°çš„ç ”ç©¶
          visible: $meta.previousInteractionId
          onClick:
            action: clearMeta
            key: previousInteractionId

  # è®¾ç½®é¢æ¿ä½œä¸º SETTINGS_GENERAL æ’æ§½çš„ç»„ä»¶
  SETTINGS_GENERAL:
    - id: deep-research-settings
      component: settings-form
      props:
        title: Deep Research è¡Œä¸ºè®¾ç½®
        icon: science
        order: 21
        fields:
          thinkingSummaries:
            type: select
            label: æ€è€ƒæ‘˜è¦
            hint: æ˜¯å¦åœ¨æµå¼è¾“å‡ºä¸­æ˜¾ç¤ºä¸­é—´æ€è€ƒè¿‡ç¨‹
            default: auto
            options:
              - { value: auto, label: è‡ªåŠ¨ (auto) }
              - { value: none, label: ä¸æ˜¾ç¤º (none) }
          pollInterval:
            type: number
            label: è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
            hint: éžæµå¼æ¨¡å¼ä¸‹æ£€æŸ¥ç ”ç©¶è¿›åº¦çš„é—´éš”
            default: 10
            min: 5
            max: 60
          maxResearchTime:
            type: number
            label: æœ€å¤§ç ”ç©¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
            hint: ç ”ç©¶ä»»åŠ¡çš„è¶…æ—¶æ—¶é—´ï¼ˆå®˜æ–¹é™åˆ¶ä¸º 60 åˆ†é’Ÿï¼‰
            default: 60
            min: 5
            max: 60

# ========== Channel è„šæœ¬ï¼ˆæ²™ç®±æ‰§è¡Œï¼‰==========
script: |
  (function() {
      'use strict';

      // å»¶è¿Ÿå‡½æ•°
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

      // è§£æž SSE äº‹ä»¶
      function parseSSEEvent(data) {
          if (!data || data === '[DONE]') return null;
          try {
              return JSON.parse(data);
          } catch (e) {
              console.warn('[DeepResearch] SSE parse error:', data, e);
              return null;
          }
      }

      const adapter = {
          async call(messages, config, onUpdate, signal) {
              let baseUrl = (config.baseUrl || 'https://generativelanguage.googleapis.com/v1beta').replace(/\/+$/, '');
              const settings = await Plugin.getSettings();
              const meta = await Plugin.getConversationMeta();
              
              // èŽ·å–æœ€åŽä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
              let inputText = '';
              let systemInstruction = '';
              for (const msg of messages) {
                  if (msg.role === 'system') systemInstruction = msg.content || '';
                  else if (msg.role === 'user') inputText = msg.content || '';
              }
              if (systemInstruction) inputText = `${systemInstruction}\n\n${inputText}`;

              const isFollowUp = !!meta.previousInteractionId;
              
              // æž„å»ºè¯·æ±‚ä½“
              const body = {
                  input: inputText,
                  agent: config.model || 'deep-research-pro-preview-12-2025'
              };

              if (!isFollowUp) {
                  body.background = true;
                  body.store = true;
              }

              const isStream = !!onUpdate && !isFollowUp;
              if (isStream) {
                  body.stream = true;
                  body.agent_config = {
                      type: 'deep-research',
                      thinking_summaries: settings.thinkingSummaries || 'auto'
                  };
              }

              if (isFollowUp) {
                  body.previous_interaction_id = meta.previousInteractionId;
              }

              const headers = {
                  'Content-Type': 'application/json',
                  'x-goog-api-key': config.apiKey
              };

              let url = `${baseUrl}/interactions${isStream ? '?alt=sse' : ''}`;

              const response = await fetch(url, {
                  method: 'POST',
                  headers,
                  body: JSON.stringify(body),
                  signal
              });

              if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`API Error ${response.status}: ${errorText}`);
              }

              if (isFollowUp) {
                  return await this.handleFollowUp(response, onUpdate);
              } else if (isStream) {
                  return await this.handleStream(response, settings, onUpdate, signal, baseUrl, headers);
              } else {
                  return await this.handlePolling(response, settings, onUpdate, signal, baseUrl, headers);
              }
          },

          async handleStream(response, settings, onUpdate, signal, baseUrl, headers) {
              const reader = response.body.getReader();
              const decoder = new TextDecoder('utf-8');
              let buffer = '';
              let fullContent = '';
              let fullReasoning = '';
              let interactionId = null;
              let isComplete = false;

              try {
                  while (true) {
                      const { done, value } = await reader.read();
                      if (done) break;

                      buffer += decoder.decode(value, { stream: true });
                      const lines = buffer.split('\n');
                      buffer = lines.pop() || '';

                      for (const line of lines) {
                          const trimmed = line.trim();
                          if (!trimmed || trimmed === 'data: [DONE]') continue;

                          if (trimmed.startsWith('data: ')) {
                              const event = parseSSEEvent(trimmed.substring(6));
                              if (!event) continue;

                              if (event.event_type === 'interaction.start' && event.interaction?.id) {
                                  interactionId = event.interaction.id;
                                  onUpdate({
                                      content: 'ðŸ”¬ æ·±åº¦ç ”ç©¶ä»»åŠ¡å·²å¯åŠ¨...',
                                      reasoning: fullReasoning || null
                                  });
                              }

                              if (event.event_type === 'content.delta') {
                                  if (event.delta?.type === 'text') {
                                      fullContent += event.delta.text || '';
                                      onUpdate({ content: fullContent, reasoning: fullReasoning || null });
                                  } else if (event.delta?.type === 'thought_summary') {
                                      fullReasoning += (event.delta.content?.text || '') + '\n\n';
                                      const displayContent = fullContent || 'ðŸ”¬ æ­£åœ¨ç ”ç©¶ä¸­...';
                                      onUpdate({ content: displayContent, reasoning: fullReasoning });
                                  }
                              }

                              if (event.event_type === 'interaction.complete') {
                                  isComplete = true;
                                  if (event.interaction?.status === 'failed') {
                                      throw new Error(`Research failed: ${event.interaction?.error?.message || 'Unknown'}`);
                                  }
                              }

                              if (event.event_type === 'error' && !isComplete) {
                                  throw new Error(`Research error: ${event.error?.message || 'Unknown'}`);
                              }
                          }
                      }
                  }
              } catch (streamError) {
                  if (!isComplete && interactionId && !signal?.aborted) {
                      return await this.pollForCompletion(interactionId, fullContent, fullReasoning, settings, onUpdate, signal, baseUrl, headers);
                  }
                  if (!signal?.aborted) throw streamError;
              }

              if (!isComplete && interactionId) {
                  return await this.pollForCompletion(interactionId, fullContent, fullReasoning, settings, onUpdate, signal, baseUrl, headers);
              }

              if (interactionId) {
                  await Plugin.setConversationMeta('previousInteractionId', interactionId);
              }

              return {
                  choices: [{
                      message: {
                          role: 'assistant',
                          content: fullContent || 'ç ”ç©¶å·²å®Œæˆã€‚',
                          reasoning_content: fullReasoning || null
                      },
                      finish_reason: 'stop'
                  }]
              };
          },

          async handleFollowUp(response, onUpdate) {
              const data = await response.json();
              let content = '';
              if (data.outputs && data.outputs.length > 0) {
                  content = data.outputs[data.outputs.length - 1].text || '';
              }

              if (onUpdate && content) {
                  onUpdate({ content, reasoning: null });
              }

              if (data.id) {
                  await Plugin.setConversationMeta('previousInteractionId', data.id);
              }

              return {
                  choices: [{
                      message: { role: 'assistant', content: content || 'æœªè¿”å›žå†…å®¹ã€‚' },
                      finish_reason: 'stop'
                  }]
              };
          },

          async handlePolling(response, settings, onUpdate, signal, baseUrl, headers) {
              const data = await response.json();
              const interactionId = data.id;
              if (!interactionId) throw new Error('No interaction ID returned');

              return await this.pollForCompletion(interactionId, '', '', settings, onUpdate, signal, baseUrl, headers);
          },

          async pollForCompletion(interactionId, currentContent, currentReasoning, settings, onUpdate, signal, baseUrl, headers) {
              const pollInterval = (settings.pollInterval || 10) * 1000;
              const maxTime = (settings.maxResearchTime || 60) * 60 * 1000;
              const startTime = Date.now();
              let fullContent = currentContent;
              let fullReasoning = currentReasoning;

              while (Date.now() - startTime < maxTime) {
                  if (signal?.aborted) throw new Error('Research cancelled');

                  const elapsedSec = Math.round((Date.now() - startTime) / 1000);
                  const statusContent = fullContent || `ðŸ”¬ ç ”ç©¶è¿›è¡Œä¸­... (${elapsedSec}ç§’)`;
                  onUpdate({ content: statusContent, reasoning: fullReasoning || null });

                  await delay(pollInterval);

                  try {
                      const pollResponse = await fetch(`${baseUrl}/interactions/${interactionId}`, {
                          method: 'GET',
                          headers,
                          signal
                      });

                      if (!pollResponse.ok) continue;
                      const result = await pollResponse.json();

                      if (result.status === 'completed') {
                          const outputs = result.outputs || [];
                          let finalContent = '';
                          for (const output of outputs) {
                              if (output.text) finalContent += output.text;
                          }
                          if (finalContent) fullContent = finalContent;

                          await Plugin.setConversationMeta('previousInteractionId', interactionId);
                          onUpdate({ content: fullContent, reasoning: fullReasoning || null });

                          return {
                              choices: [{
                                  message: {
                                      role: 'assistant',
                                      content: fullContent || 'ç ”ç©¶å·²å®Œæˆã€‚',
                                      reasoning_content: fullReasoning || null
                                  },
                                  finish_reason: 'stop'
                              }]
                          };
                      }

                      if (result.status === 'failed') {
                          throw new Error(`Research failed: ${result.error || 'Unknown'}`);
                      }
                  } catch (pollError) {
                      if (signal?.aborted) throw pollError;
                      console.warn('[DeepResearch] Poll error:', pollError.message);
                  }
              }

              throw new Error(`Research timed out after ${settings.maxResearchTime} minutes`);
          },

          async fetchModels(config) {
              return ['deep-research-pro-preview-12-2025'];
          }
      };

      Plugin.registerChannel(adapter);
  })();